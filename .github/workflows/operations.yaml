---
name: 'Source operation checks'

on:
  push:
    branches-ignore:
      - 'main'
#   schedule:
#     - cron:  "42 7 15 * *" #build project on the 15th day of every month on the 42nd minute of the 7th hour.

env:
    # Job vars.
    UPDATE_ENVIRONMENT: so-updates
    OPERATION_NAME: update
    # Dependencies.
    POETRY_VERSION: '1.1.11'
    # Auth.
    GITHUB_TOKEN: ${{ secrets.DEVREL_TOKEN }}
    PLATFORMSH_CLI_TOKEN: ${{ secrets.PSH_CLI_TOKEN }}
    # Notifications.
    SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
    SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
    JOB_ID: 'source operations'
    START_MESSAGE: 'Testing user-facing source operations for all templates.'
    JOB_COLOR: "#FF9F9F"

jobs:
    build:
        runs-on: ubuntu-latest
        name: 'Get templates'
        outputs:
            templates: ${{ steps.getlist.outputs.templates }}
            threadts: ${{ steps.startslack.outputs.threadts }}
        steps: 
          - uses: actions/checkout@v2
          - name: Setup Python
            uses: actions/setup-python@v2
            with:
              python-version: 3.9
          - name: 'Get template list'
            id: getlist
            run: |
              TEMPLATES=$(python -c '
              import os
              import json
              dirs=os.listdir("{}/templates".format(os.getcwd()))
              dirs.remove("__init__.py")
              test = {"template": dirs}
              print(json.dumps(dirs))
              ')
              echo "::set-output name=templates::$TEMPLATES"
          - name: Install Poetry
            run: |
              python -m pip install poetry==$POETRY_VERSION
          - name: Configure Poetry
            run: |
              python -m poetry config virtualenvs.in-project true
          - name: Cache the virtualenv
            uses: actions/cache@v2
            with:
              path: ./.venv
              key: ${{ runner.os }}-venv-${{ hashFiles('**/poetry.lock') }}
          - name: Install dependencies
            run: |
              python -m poetry install
          - name: 'Start notification on Slack'
            id: startslack
            run: |
              RUN_URL=https://github.com/platformsh/starter-builder/actions/runs/$GITHUB_RUN_ID
              THREAD_ID=$(SLACK_BOT_TOKEN=$SLACK_TOKEN CHANNEL_ID=$SLACK_CHANNEL_ID JOB_ID="$JOB_ID" JOB_COLOR=$JOB_COLOR poetry run python slack_notifier.py start $RUN_URL "$START_MESSAGE")
              echo "::set-output name=threadts::$THREAD_ID"

    test:
        needs: build
        runs-on: ubuntu-latest
        name: 'SO Update test'
        strategy:
            fail-fast: false
            matrix: 
                template: ${{fromJSON(needs.build.outputs.templates)}}
                exclude:
                  - template: 'nuxtjs'
                  - template: 'pimcore'
                  - template: 'django3'
                  - template: 'microprofile-wildfly'
                  - template: 'symfony5'
                  - template: 'django2'
                  - template: 'gatsby-strapi'
                  - template: 'drupal8-opigno'
                  - template: 'echo'
                  - template: 'python3'
                  - template: 'nextjs'
                  - template: 'express'
                  - template: 'drupal8'
                  - template: 'spring-kotlin'
                  - template: 'eleventy-strapi'
                  - template: 'koa'
                  - template: 'microprofile-openliberty'
                  - template: 'gatsby-wordpress'
                  - template: 'pyramid'
                  - template: 'mattermost'
                  - template: 'backdrop'
                  - template: 'golang'
                  - template: 'wordpress-woocommerce'
                  - template: 'strapi'
                  - template: 'magento2ce'
                  - template: 'nextcloud'
                  - template: 'microprofile-helidon'
                  - template: 'python3-uwsgi'
                  - template: 'beego'
                  - template: 'meilisearch'
                  - template: 'django3'
                  - template: 'gatsby'
                  - template: 'microprofile-tomee'
                  - template: 'akeneo'
                  - template: 'symfony4'
                  - template: 'microprofile-kumuluzee'
                  - template: 'nodejs'
                  - template: 'wordpress-bedrock'
                  - template: 'tomcat'
                  - template: 'typo3'
                  - template: 'wordpress-vanilla'
                  - template: 'elastic-apm'
                  - template: 'probot'
                  - template: 'flask'
                  - template: 'drupal8-multisite'
                  - template: 'jetty'
                  - template: 'lisp'
                  - template: 'spring-boot-gradle-mysql'
                  - template: 'drupal8-govcms8'
                  - template: 'wagtail'
                  - template: 'php'
                  - template: 'jenkins'
                  - template: 'microprofile-thorntail'
                  - template: 'laravel'
                  - template: 'quarkus'
                  - template: 'xwiki'
                  - template: 'spring-boot-maven-mysql'
                  - template: 'spring-mvc-maven-mongodb'
                  - template: 'micronaut'
                  - template: 'pelican'
                  - template: 'wordpress-composer'
                  - template: 'rails'
                  - template: 'aspnet-core'
                  - template: 'gin'
                  - template: 'drupal9'
                  - template: 'gatsby-drupal'
                  - template: 'microprofile-payara'
                  - template: 'sculpin'
                  - template: 'hugo'
        steps: 

        # jobs.<job_id>.steps[*].timeout-minutes for extended activities and curls
        
        # 1. SETTING UP 
        - uses: actions/checkout@v2
        - name: Install Poetry
          run: |
            python -m pip install poetry==$POETRY_VERSION
        - name: Configure Poetry
          run: |
            python -m poetry config virtualenvs.in-project true
        - name: Cache the virtualenv
          uses: actions/cache@v2
          with:
            path: ./.venv
            key: ${{ runner.os }}-venv-${{ hashFiles('**/poetry.lock') }}
        - name: Install dependencies
          run: |
            python -m poetry install

        # 2. CHECKING FOR PREVIOUS UPDATES IN PROGRESS/INVESTIGATION
        # check if the branch already exists. (outputs: GH branch message)
        - name: Check if SO branch exists on GH
          id: branchstatus
          run: |
            STATUS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/platformsh-templates/${{ matrix.template }}/branches/$UPDATE_ENVIRONMENT)
            echo "::set-output name=status::$( echo $STATUS | jq -r '.message' )"
        # Skip the template if the update environment already exists.
        - name: Exit if SO branch exists
          if: steps.branchstatus.outputs.status != 'Branch not found'
          run: |
            TEMPLATE=${{ matrix.template }} 
            MESSAGE="Source operation update branch already exists. Skipping template until investigation on open branch (https://github.com/platformsh-templates/$TEMPLATE/tree/$UPDATE_ENVIRONMENT) is closed."
            echo "$MESSAGE"
            RUN_URL=https://github.com/platformsh/starter-builder/actions/runs/$GITHUB_RUN_ID
            PR_URL='no pr'
            THREAD_ID=${{ needs.build.outputs.threadts }}
            RESULT=$(SLACK_BOT_TOKEN=$SLACK_TOKEN CHANNEL_ID=$SLACK_CHANNEL_ID THREAD_ID=$THREAD_ID poetry run python slack_notifier.py skip $TEMPLATE "$RUN_URL" "$PR_URL" "$MESSAGE")

        # 1. CREATING THE SO-UPDATE BRANCH
        # identify the default branch for the template repo. (outputs: GH repo default branch name)
        - name: Get template default branch
          id: defaultbranch
          if: steps.branchstatus.outputs.status == 'Branch not found'
          run: |
            # Get the default branch.
            DEFAULT_BRANCH=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/platformsh-templates/${{ matrix.template }} | jq -r '.default_branch')
            echo "::set-output name=branch::$DEFAULT_BRANCH" 
        # identify commit SHA on the default branch. (outputs: GH repo default branch SHA)
        - name: Get default branch SHA
          if: steps.branchstatus.outputs.status == 'Branch not found'
          id: defaultsha
          run: |
            DEFAULT_BRANCH=${{ steps.defaultbranch.outputs.branch }}
            # Get the default branch SHA.
            SHA=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/platformsh-templates/${{ matrix.template }}/branches/$DEFAULT_BRANCH)
            echo "::set-output name=sha::$( echo $SHA | jq -r '.commit.sha' )" 
        # create the update branch on GH. (outputs: none)
        - name: Create update branch
          if: steps.branchstatus.outputs.status == 'Branch not found'
          run: |
            DEFAULT_BRANCH_SHA=${{ steps.defaultsha.outputs.sha }}
            UPDATE_BRANCH_REF=refs/heads/$UPDATE_ENVIRONMENT
            echo "Creating $UPDATE_BRANCH_REF from $DEFAULT_BRANCH_SHA"
            DATA=$( jq -n \
                        --arg ref "$UPDATE_BRANCH_REF" \
                        --arg sha "$DEFAULT_BRANCH_SHA" \
                        '{ref: $ref, sha: $sha}' )
            curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/json" \
                -d "$DATA" \
                https://api.github.com/repos/platformsh-templates/${{ matrix.template }}/git/refs
            sleep 5

        # 2. ACTIVATING THE SO UPDATE ENVIRONMENT
        # install Platform.sh CLI. (outputs: none)
        - uses: actions/checkout@v2
        - name: Install Platform.sh CLI
          if: steps.branchstatus.outputs.status == 'Branch not found'
          run: |
            curl -sS https://platform.sh/cli/installer | php
        - name: Get the Project ID
          if: steps.branchstatus.outputs.status == 'Branch not found'
          id: projectid
          run: |
            PROJECT_ID=$(~/.platformsh/bin/platform project:list --title="${{ matrix.template }}" --no-header --columns=ID --format=plain)
            ID_LENGTH=$(echo ${#PROJECT_ID})
            # A single project id has length 13.
            if [ $ID_LENGTH -gt 14 ];then
              echo "Failed. More than one project retrieved for Title: ${{ matrix.template}}"
              echo "  * IDs: $PROJECT_ID"
              exit 1
            else
              echo "Success! Project $PROJECT_ID found for template (${{ matrix.template }})."
            fi
            echo "::set-output name=result::$PROJECT_ID"
        # get the project ID for the template repo. (outputs: project_id)
        - name: Activate so-update environment
          if: steps.branchstatus.outputs.status == 'Branch not found'
          run: |
            PROJECT_ID=${{ steps.projectid.outputs.result }}
            ~/.platformsh/bin/platform environment:activate $UPDATE_ENVIRONMENT -p $PROJECT_ID -y --no-wait

        # 3. RETRIEVE ENVIRONMENT ACTIVATION
        # Get the most recent activity. (outputs: activity ID)
        - name: Get activity ID
          if: steps.branchstatus.outputs.status == 'Branch not found'
          id: getactivity
          run: |
            PROJECT_ID=${{ steps.projectid.outputs.result }}
            ACTIVITY_ID=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT/activities  | jq -r '.[0].id')
            echo "::set-output name=id::$ACTIVITY_ID"
        - name: Check activity status
          if: steps.branchstatus.outputs.status == 'Branch not found'
          timeout-minutes: 5
          id: activityresult
          run: |
            PROJECT_ID=${{ steps.projectid.outputs.result }}
            ACTIVITY_ID=${{ steps.getactivity.outputs.id }}
            ./wait_for_activity_complete.sh $PROJECT_ID $UPDATE_ENVIRONMENT $ACTIVITY_ID
            ACTIVITY_RESULT=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT/activities/$ACTIVITY_ID | jq -r '.result')
            echo "::set-output name=result::$ACTIVITY_RESULT"
        - name: Break on activity failure
          if: steps.activityresult.outputs.result != 'success'
          run: |
            TEMPLATE=${{ matrix.template }} 
            RUN_URL=https://github.com/platformsh/starter-builder/actions/runs/$GITHUB_RUN_ID
            PR_URL='no pr'
            MESSAGE='Some long failure message that you should go investigate'
            RESULT=$(SLACK_BOT_TOKEN=$SLACK_BOT_TOKEN CHANNEL_ID=$CHANNEL_ID THREAD_ID=$THREAD_ID poetry run python token_notifier.py down $TEMPLATE "$RUN_URL" "$PR_URL" "$MESSAGE")
            exit 1

    #     # 4. CHECK THE ACTIVATED ENVIRONMENT
    #     - name: Install Poetry
    #       run: |
    #         python -m pip install poetry==1.1.11
    #     - name: Configure Poetry
    #       run: |
    #         python -m poetry config virtualenvs.in-project true
    #     - name: Cache the virtualenv
    #       uses: actions/cache@v2
    #       with:
    #         path: ./.venv
    #         key: ${{ runner.os }}-venv-${{ hashFiles('**/poetry.lock') }}
    #     - name: Install dependencies
    #       run: |
    #         python -m poetry install
    #     - name: Verify environment
    #       if: steps.activityresult.outputs.result == 'success'
    #       run: |
    #         PROJECT_ID=${{ steps.projectid.outputs.result }}
    #         URL=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT | jq -r '._links."public-url".href')

    #         STATUS=$(URL=$URL python -m poetry run python get_status.py)
    #         if [ $STATUS -ne 200 ]; then
    #           echo "Failed."
    #           exit 1
    #         else
    #           echo "Passed."
    #         fi

    #     # 5. RUN THE OPERATION
    #     - name: Run source operation
    #       run: |
    #         PROJECT_ID=${{ steps.projectid.outputs.result }}
    #         ~/.platformsh/bin/platform source-operation:run $OPERATION_NAME -p $PROJECT_ID -e $UPDATE_ENVIRONMENT --no-wait

    #     # 6. FOLLOW UP ON THE SOURCE OPERATION
    #     - name: Get activity ID
    #       id: getSOactivity
    #       run: |
    #         PROJECT_ID=${{ steps.projectid.outputs.result }}
    #         ACTIVITY_ID=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT/activities  | jq -r '.[0].id')
    #         echo "::set-output name=id::$ACTIVITY_ID"
    #     - name: Check activity status
    #       id: activitySOresult
    #       run: |
    #         PROJECT_ID=${{ steps.projectid.outputs.result }}
    #         ACTIVITY_ID=${{ steps.getSOactivity.outputs.id }}

    #         ACTIVITY_STATE="in_progress"
    #         until [ $ACTIVITY_STATE == "complete" ];do
    #           sleep 10
    #           ACTIVITY_STATE=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT/activities/$ACTIVITY_ID | jq -r '.state')
    #           echo "Activity state: $ACTIVITY_STATE"
    #         done
    #         ACTIVITY_RESULT=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT/activities/$ACTIVITY_ID | jq -r '.result')
            
    #         echo "::set-output name=result::$ACTIVITY_RESULT"
    #     - name: Break on activity failure
    #       if: steps.activitySOresult.outputs.result != 'success'
    #       run: |
    #         exit 1

    #     # 7. FOLLOW UP ON THE SO COMMIT
    #     - name: Get Commit activity ID
    #       id: getCommitactivity
    #       run: |
    #         PROJECT_ID=${{ steps.projectid.outputs.result }}
    #         ACTIVITY_ID=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT/activities  | jq -r '.[0].id')
    #         echo "::set-output name=id::$ACTIVITY_ID"
    #     - name: Check activity status
    #       id: activityCommitresult
    #       run: |
    #         PROJECT_ID=${{ steps.projectid.outputs.result }}
    #         ACTIVITY_ID=${{ steps.getCommitactivity.outputs.id }}

    #         ACTIVITY_STATE="in_progress"
    #         until [ $ACTIVITY_STATE == "complete" ];do
    #           sleep 10
    #           ACTIVITY_STATE=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT/activities/$ACTIVITY_ID | jq -r '.state')
    #           echo "Activity state: $ACTIVITY_STATE"
    #         done
    #         ACTIVITY_RESULT=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT/activities/$ACTIVITY_ID | jq -r '.result')
            
    #         echo "::set-output name=result::$ACTIVITY_RESULT"
    #     - name: Break on activity failure
    #       if: steps.activityCommitresult.outputs.result != 'success'
    #       run: |
    #         exit 1
    #     - name: Verify environment
    #       if: steps.activityCommitresult.outputs.result == 'success'
    #       run: |
    #         PROJECT_ID=${{ steps.projectid.outputs.result }}
    #         URL=$(~/.platformsh/bin/platform project:curl -p $PROJECT_ID environments/$UPDATE_ENVIRONMENT | jq -r '._links."public-url".href')

    #         STATUS=$(URL=$URL python -m poetry run python get_status.py)
    #         if [ $STATUS -ne 200 ]; then
    #           echo "Failed."
    #           exit 1
    #         else
    #           echo "Passed."
    #         fi

